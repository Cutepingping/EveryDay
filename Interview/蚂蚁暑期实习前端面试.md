# 蚂蚁暑期实习前端面试
这次面试的是蚂蚁的智能协同事业部，也就是语雀这个产品线，`okbug`非得给我推，今年到目前为止也就面了两家，再面一家不过分吧，所以`okbug`就给我推了。`2022.03.12`上午`11`点左右投的，然后还要做测评，这个挺烦人的，不过也很快就做完了。

## 一面
周六上午`11`点左右投了，晚上七点就给我打电话，约了一面，并且还给了三道笔试题让我抽空做完，一面约的时间是在`2021-03-16 18:00`。







```javascript
class Node {
    constructor({ value, level, parent }) {
        this.value = value;
        this.level = level;
        this.children = [];
        this.parent = parent;
        // hint: 也可在数据结构中增加 this.parent 节点辅助解析
    }
}

const str = `
- 章节一
  - 标题一
    - 子标题一
- 章节二
    - 章节二子子标题
- 标题一
- 标题二
`;

function parseTree(text) {
    const lines = text.split("\n");
    let curLevel = 0;
    let preIndex = 0;
    const target = [];
    let preNode = null;
    let parentNode = null;
    lines.forEach(line => {
        if(line === "") return void 0;
        if(!/^[\s]*- /.test(line)) throw new Error("Each line should start with - ");
        const index = line.indexOf("- ");
        if(index % 2 !== 0) throw new Error("Start tabs must be even");
        let levelChange = Math.floor(Math.abs(index - preIndex) / 2); // 层级变动
        if(index > preIndex) {
            while(levelChange--){
                curLevel++;
                parentNode = preNode;
                if(levelChange > 0) { // 如果从1级标题直接到三级标题等 加入空节点
                    preNode = new Node({
                        value: "Empty Node",
                        level: curLevel,
                        parent: parentNode
                    });
                    parentNode.children.push(preNode);
                }
            }
        }else if(index < preIndex){
            while(levelChange--){
                curLevel--;
                if(parentNode) parentNode = parentNode.parent;
                else parentNode = null;
            }
        } 
        preIndex = index;
        const node = new Node({
            value: line.slice(index + 2, line.length), 
            level: curLevel, 
            parent: parentNode
        });
        if(parentNode) parentNode.children.push(node);
        else target.push(node);
        preNode = node;
    })
    return target;
}

const result = parseTree(str);
const output = node => {
    console.log(new Array(node.level).fill("  ").join(""), node.value, node.level);
    node.children.forEach(item => output(item));
}
result.forEach(item => output(item));
```
