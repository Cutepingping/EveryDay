# 蚂蚁暑期实习前端面试
这次面试的是蚂蚁的智能协同事业部，也就是语雀这个产品线，`okbug`非得给我推，今年到目前为止也就面了两家，再面一家不过分吧，所以`okbug`就给我推了。`2022.03.12`上午`11`点左右投的，然后还要做测评，这个挺烦人的，不过也很快就做完了。

## 一面
周六上午`11`点左右投了，晚上七点就给我打电话，约了一面，并且还给了三道笔试题让我做完，一面约的时间是在`2021-03-16 19:00`，面试时间有`55min`。

* 笔试第一题，解析目录成为树结构。
* 笔试第二题，数组去重。
* 笔试第三题，`Promise`的串行执行。
* 油猴脚本的实现，主要是什么内容，这个是我在`Github`开源的脚本。
* 腾讯实习的时候的主要工作，做直播业务时遇到的问题。
* 前端框架和前端工程化方面的了解。
* 登录注册的前后端整体流程。
* 手机验证码登陆的前后端整体流程，具体细节怎么做。
* 如果用户一直收不到验证码都可能有什么问题。
* 如何做到数据传输的安全。
* 数据安全具体是防范什么问题的。
* `Node`做后端的相关了解。
* 前端后端偏向于哪里。
* `ThinkPHP`如何处理的页面输出或者是接口。
* 服务器的性能监控、异常监控如何做。
* 服务器`CPU`突然爆表如何处理，如何排查问题。
* 后端的代码的异常监控，告警处理。
* 前端和后端如何平滑过渡升级。
* 多台服务器如何平滑处理后端升级。
* 容器`docker`相关的内容。
* 数据库相关的内容。
* `babel`如何处理的代码，相关原理。
* 笔试第一题相关的解析字符串结构的相关方案。
* 笔试第二题还有哪些处理方案，时间空间复杂度，`10`亿个数字怎么处理。
* 小程序如何处理卡顿问题。
* 前端如何进行性能的指标排查与相关工具，如何定位问题。
* 如何优化页面的性能。

反问阶段是问了一下语雀相关的业务组，好家伙我以为是前端，原来是全栈，包括前端后端数据库运维，当然具体是分组安排的。说实话本来我以为一面应该是一个比较轻松的面试，没想到给我问懵了，全都是场景题，人都问傻了，不过面试体验还是很不错的，面试的老哥都还是会给予一些提示的，老哥就是有点不苟言笑哈哈哈。对了老哥还是今年面试过程中目前我知道的唯一一个在面试前就去翻我`Github`的，老哥真不错哈哈哈。附一下当时写的笔试题第一题的代码。

```javascript
class Node {
    constructor({ value, level, parent }) {
        this.value = value;
        this.level = level;
        this.children = [];
        this.parent = parent;
        // hint: 也可在数据结构中增加 this.parent 节点辅助解析
    }
}

const str = `
- 章节一
  - 标题一
    - 子标题一
- 章节二
    - 章节二子子标题
- 标题一
- 标题二
`;

function parseTree(text) {
    const lines = text.split("\n");
    let curLevel = 0;
    let preIndex = 0;
    const target = [];
    let preNode = null;
    let parentNode = null;
    lines.forEach(line => {
        if(line === "") return void 0;
        if(!/^[\s]*- /.test(line)) throw new Error("Each line should start with - ");
        const index = line.indexOf("- ");
        if(index % 2 !== 0) throw new Error("Start tabs must be even");
        let levelChange = Math.floor(Math.abs(index - preIndex) / 2); // 层级变动
        if(index > preIndex) {
            while(levelChange--){
                curLevel++;
                parentNode = preNode;
                if(levelChange > 0) { // 如果从1级标题直接到三级标题等 加入空节点
                    preNode = new Node({
                        value: "Empty Node",
                        level: curLevel,
                        parent: parentNode
                    });
                    parentNode.children.push(preNode);
                }
            }
        }else if(index < preIndex){
            while(levelChange--){
                curLevel--;
                if(parentNode) parentNode = parentNode.parent;
                else parentNode = null;
            }
        } 
        preIndex = index;
        const node = new Node({
            value: line.slice(index + 2, line.length), 
            level: curLevel, 
            parent: parentNode
        });
        if(parentNode) parentNode.children.push(node);
        else target.push(node);
        preNode = node;
    })
    return target;
}

const result = parseTree(str);
const output = node => {
    console.log(new Array(node.level).fill("  ").join(""), node.value, node.level);
    node.children.forEach(item => output(item));
}
result.forEach(item => output(item));
```
